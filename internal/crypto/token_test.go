package crypto

import (
	"strings"
	"testing"
	"time"
)

func TestGenerateKeyPair(t *testing.T) {
	key, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("GenerateKeyPair failed: %v", err)
	}
	if key == nil {
		t.Fatal("GenerateKeyPair returned nil")
	}
	if len(key.publicKey) == 0 {
		t.Error("Public key is empty")
	}
	if len(key.privateKey) == 0 {
		t.Error("Private key is empty")
	}
}

func TestGenerateTokenTimestamp(t *testing.T) {
	key, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("GenerateKeyPair failed: %v", err)
	}

	token, err := key.GenerateTokenTimestamp()
	if err != nil {
		t.Fatalf("GenerateTokenTimestamp failed: %v", err)
	}

	// Token format: sha256.{hash}.{salt}.ed25519.{signature}
	if token == "" {
		t.Error("Token is empty")
	}

	// Verify the token
	verifyingKey := key.ToVerifyingKey()
	err = VerifyTokenTimestamp(verifyingKey, token)
	if err != nil {
		t.Errorf("VerifyTokenTimestamp failed: %v", err)
	}
}

func TestGenerateTokenWithNonce(t *testing.T) {
	key, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("GenerateKeyPair failed: %v", err)
	}

	nonce, err := GenerateNonce()
	if err != nil {
		t.Fatalf("GenerateNonce failed: %v", err)
	}

	token, err := key.GenerateToken(nonce)
	if err != nil {
		t.Fatalf("GenerateToken failed: %v", err)
	}

	// Verify with correct nonce
	verifyingKey := key.ToVerifyingKey()
	err = VerifyTokenNonce(verifyingKey, token, nonce)
	if err != nil {
		t.Errorf("VerifyTokenNonce failed: %v", err)
	}

	// Verify with wrong nonce should fail
	wrongNonce := make([]byte, 32)
	err = VerifyTokenNonce(verifyingKey, token, wrongNonce)
	if err == nil {
		t.Error("VerifyTokenNonce should fail with wrong nonce")
	}
}

func TestTokenExpiry(t *testing.T) {
	key, err := GenerateKeyPair()
	if err != nil {
		t.Fatalf("GenerateKeyPair failed: %v", err)
	}

	// Generate a token with a timestamp from 2 hours ago
	oldTimestamp := time.Now().Add(-2 * time.Hour).Unix()
	salt := make([]byte, 8)
	salt[0] = byte(oldTimestamp)
	salt[1] = byte(oldTimestamp >> 8)
	salt[2] = byte(oldTimestamp >> 16)
	salt[3] = byte(oldTimestamp >> 24)
	salt[4] = byte(oldTimestamp >> 32)
	salt[5] = byte(oldTimestamp >> 40)
	salt[6] = byte(oldTimestamp >> 48)
	salt[7] = byte(oldTimestamp >> 56)

	token, err := key.GenerateToken(salt)
	if err != nil {
		t.Fatalf("GenerateToken failed: %v", err)
	}

	// Verify should fail because token is expired
	verifyingKey := key.ToVerifyingKey()
	err = VerifyTokenTimestamp(verifyingKey, token)
	if err == nil {
		t.Error("VerifyTokenTimestamp should fail for expired token")
	}
}

func TestExtractSignatureMethod(t *testing.T) {
	tests := []struct {
		token    string
		expected string
	}{
		{"sha256.abc.def.ed25519.sig", "ed25519"},
		{"sha256.abc.def.rsa-pss.sig", "rsa-pss"},
		{"invalid", ""},
	}

	for _, tt := range tests {
		got := ExtractSignatureMethod(tt.token)
		if got != tt.expected {
			t.Errorf("ExtractSignatureMethod(%q) = %q; want %q", tt.token, got, tt.expected)
		}
	}
}

// =============================================================================
// Rust Test Vectors
// These tests verify token generation and verification compatibility with the 
// official Rust implementation using exact values from Rust unit tests.
// =============================================================================

// TestTokenVerificationRustVector verifies verification logic against a known
// valid token generated by the official Rust implementation.
func TestTokenVerificationRustVector(t *testing.T) {
	// From Rust tests (core/src/crypto/token.rs)
	publicKeyPEM := "-----BEGIN PUBLIC KEY-----\nMCowBQYDK2VwAyEAZmdXP230oqK92o65ra3XaF2F8r3+fK5DEBK4c40qVts=\n-----END PUBLIC KEY-----"
	token := "sha256.RikOdJlAUTdMVFZjEk7Bft5G9cxnNBBLfgttPpyS2FY.hJCuZwAAAAA.ed25519.iNgHrRzX2Iel-Ozj47yn5o5v0cGY_BswK6JYqwY65j7Krpr43KanAaCrjUng7gHtc2pCcylUrKswR_rxyswhDA"
	
	// The salt in this token is "hJCuZwAAAAA" which is base64-url-safe-no-pad for [0x84, 0x90, 0xae, 0x67, 0x00, 0x00, 0x00, 0x00]
	// but VerifyTokenNonce should handle decoding it from the token itself.
	
	// Parse the public key
	key, err := ParsePublicKeyPEM(publicKeyPEM)
	if err != nil {
		t.Fatalf("ParsePublicKeyPEM failed: %v", err)
	}
	
	// Salt is extracted from the token by VerifyTokenNonce if we pass nil or the correct bytes
	// However, VerifyTokenNonce in current implementation might expect it as an argument.
	// Let's decode the salt from the token to pass it.
	parts := strings.Split(token, ".")
	if len(parts) != 5 {
		t.Fatalf("Invalid token format: %d parts", len(parts))
	}
	
	salt, err := DecodeNonce(parts[2])
	if err != nil {
		t.Fatalf("Failed to decode salt from token: %v", err)
	}
	
	// Verify the token
	err = VerifyTokenNonce(key, token, salt)
	if err != nil {
		t.Errorf("VerifyTokenNonce failed: %v", err)
	}
}

// TestRsaPssVerifyingKeyMethods tests RSA-PSS verifying key interface methods.
func TestRsaPssVerifyingKeyMethods(t *testing.T) {
	// Generate an RSA key pair for testing
	rsaPem := `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4xzPPpFr98WrF5cV4J0I
E6pJ2sDV2lL7LfJ2+p8qbMmq8L3gPNFMlHp3K8sP7xPxJlVN0gQN7oF0J8vB1N5S
0Vv3ZuCN8qZcK8Ss7lZvXL8RDJVmT5hXl9cBfKL0B3Xv+Y5gK9K5yVVG8LCL0N5I
lLfJ2+p8qbMmq8L3gPNFMlHp3K8sP7xPxJlVN0gQN7oF0J8vB1N5S0Vv3ZuCN8qZ
cK8Ss7lZvXL8RDJVmT5hXl9cBfKL0B3Xv+Y5gK9K5yVVG8LCL0N5IlLfJ2+p8qbM
mq8L3gPNFMlHp3K8sP7xPxJlVN0gQN7oF0J8vB1N5S0Vv3ZuCN8qZcK8Ss7lZvXL
8QIDAQAB
-----END PUBLIC KEY-----`

	key, err := ParsePublicKeyPEM(rsaPem)
	if err != nil {
		t.Fatalf("Failed to parse RSA PEM: %v", err)
	}

	// Verify it's recognized as RSA-PSS
	if key.SignatureMethod() != "rsa-pss" {
		t.Errorf("SignatureMethod() = %s; want rsa-pss", key.SignatureMethod())
	}

	// Verify ToDER works
	der, err := key.ToDER()
	if err != nil {
		t.Fatalf("ToDER failed: %v", err)
	}
	if len(der) == 0 {
		t.Error("ToDER returned empty")
	}
}

